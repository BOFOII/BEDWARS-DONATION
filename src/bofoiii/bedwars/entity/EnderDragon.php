<?php

/**
 * Special Thanks For: SandhyR, MadeAja, GamakCZ
 */

namespace bofoiii\bedwars\entity;

use bofoiii\bedwars\utils\Utils;
use pocketmine\entity\EntitySizeInfo;
use pocketmine\entity\Living;
use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\nbt\tag\CompoundTag;
use pocketmine\network\mcpe\protocol\MoveActorAbsolutePacket;
use pocketmine\network\mcpe\protocol\types\entity\EntityIds;
use pocketmine\player\Player;
use pocketmine\world\particle\AngryVillagerParticle;


class EnderDragon extends Living
{

    public const NETWORK_ID = EntityIds::ENDER_DRAGON;

    /** @var ?DragonTargetManager $targetManager */
    public ?DragonTargetManager $targetManager;

    /** @var float $width */
    public float $width = 8.0;
    /** @var float $height */
    public float $height = 4.0;

    /** @var bool $isRotating */
    public bool $isRotating = false;
    /** @var int $rotationTicks */
    public int $rotationTicks = 0;
    /** @var float $lastRotation */
    public float $lastRotation = 0.0;
    /** @var int $rotationChange */
    public int $rotationChange; // from 5 to 10 (- or +)
    /** @var int $pitchChange */
    public int $pitchChange;

    public array $array_of_team = [];

    public ?string $owner_team = null;

    public ?string $color = null;

    public function initEntity(CompoundTag $nbt): void
    {
        parent::initEntity($nbt); // TODO: Change the autogenerated stub
        $this->targetManager = null;
        $this->array_of_team = [];
        $this->owner_team = null;
        $this->color = null;
    }


    public function getOwnerTeam()
    {
        return $this->owner_team;
    }

    public function changeRotation(bool $canStart = false)
    {
        // checks for new rotation
        if (!$this->isRotating) {
            if (!$canStart) {
                return;
            }

            if (microtime(true) - $this->lastRotation < 10) {
                return;
            }

            $this->rotationChange = mt_rand(5, 30);
            if (mt_rand(0, 1) === 0) {
                $this->rotationChange *= -1;
            }
            $this->pitchChange = mt_rand(-4, 4);

            $this->isRotating = true;
        }

        // checks for rotation cancel
        if ($this->rotationTicks > mt_rand(5, 8)) {
            $this->lastRotation = microtime(true);
            $this->isRotating = false;
            return;
        }

        $this->setRotation(fmod($this->getLocation()->getYaw() + ($this->rotationChange / 3), 360), fmod($this->getLocation()->getPitch() + ($this->pitchChange / 10), 360));
        $this->rotationTicks++;
    }

    /**
     * @param int $tickDiff
     * @return bool
     */
    public function entityBaseTick(int $tickDiff = 1): bool
    { // TODO - make better movement system
        $return = parent::entityBaseTick($tickDiff);
        if ($this->targetManager === null) {
            $this->flagForDespawn();
            return false;
        }
        if (
            $this->getPosition()->distance($this->targetManager->mid) >= DragonTargetManager::MAX_DRAGON_MID_DIST
            || $this->getPosition()->getY() < 4 || $this->getPosition()->getY() > 250

        ) {
            $this->lookAt($this->targetManager->getDragonTarget($this->getOwnerTeam()));
            $this->setMotion($this->getDirectionVector());
            return true;
        }

        $this->changeRotation();
        $this->setMotion($this->getDirectionVector());
        return $return;
    }

    /**
     * Wtf mojang
     * - Function edited to send +180 yaw
     *
     * @param bool $teleport
     */
    protected function broadcastMovement(bool $teleport = false): void
    {
        $pk = new MoveActorAbsolutePacket();
        $pk->actorRuntimeId = $this->id;
        $pk->position = $this->getOffsetPosition($this->getPosition()->asVector3());

        //this looks very odd but is correct as of 1.5.0.7
        //for arrows this is actually x/y/z rotation
        //for mobs x and z are used for pitch and yaw, and y is used for headyaw
        $pk->pitch = $this->getLocation()->getPitch();
        $pk->yaw = fmod($this->getLocation()->getYaw() + 180, 360); //TODO: head yaw
        $pk->headYaw = fmod($this->getLocation()->getYaw() + 180, 360);

        if ($teleport) {
            $pk->flags |= MoveActorAbsolutePacket::FLAG_TELEPORT;
        }

        $this->getWorld()->broadcastPacketToViewers($this->getPosition()->asVector3(), $pk);
    }

    /**
     * @param EntityDamageEvent $source
     */
    public function attack(EntityDamageEvent $source): void
    {
        if ($source instanceof EntityDamageByEntityEvent) {
            $damager = $source->getDamager();
            if ($damager instanceof Player) {
                if (in_array(strtolower($damager->getName()), $this->array_of_team)) {
                    $source->cancel();
                    return;
                }
                if (isset($this->targetManager->plugin->spectators[$damager->getName()])) {
                    $source->cancel();
                    return;
                }
            }
        }

        if ($source->getCause() !== $source::CAUSE_ENTITY_ATTACK && $source->getCause() !== $source::CAUSE_PROJECTILE) {
            $source->cancel();
        }

        if ($source instanceof EntityDamageByEntityEvent && $source->getCause() === $source::CAUSE_PROJECTILE) {
            $this->setRotation(fmod($this->getLocation()->getYaw() + 180, 360), fmod($this->getLocation()->getPitch() + 180, 360));
            $this->setMotion($this->getDirectionVector());

            for ($x = -10; $x < 10; $x++) {
                for ($y = -10; $y < 10; $y++) {
                    for ($z = -10; $z < 10; $z++) {
                        if ($this->getPosition()->distance($this->getPosition()->add($x, $y, $z)) < 5) {
                            $this->getWorld()->addParticle($this->getPosition()->add($x, $y, $z), new AngryVillagerParticle());
                        }
                    }
                }
            }
        }

        parent::attack($source);
    }

    /**
     * @param Player $player
     */
    public function onCollideWithPlayer(Player $player): void
    {
        if (!in_array(strtolower($player->getName()), $this->array_of_team)) {
            $player->attack(new EntityDamageByEntityEvent($this, $player, EntityDamageEvent::CAUSE_ENTITY_ATTACK, 0.5, knockBack: 5.0));
        }
        parent::onCollideWithPlayer($player);
    }

    protected function move(float $dx, float $dy, float $dz): void
    {
        parent::move($dx, $dy, $dz); // TODO: Change the autogenerated stub
        $list = $this->getWorld()->getCollisionBoxes($this, $this->getWorld()->getTickRateTime() > 50 ? $this->boundingBox->offsetCopy($dx, $dy, $dz) : $this->boundingBox->addCoord($dx, $dy, $dz), false);
        foreach ($list as $bb) {
            $this->targetManager->removeBlock($this, (int)$bb->minX, (int)$bb->minY, (int)$bb->minZ);
        }
        foreach (Utils::getCollisionBlocks($this->getWorld(), $this->boundingBox->addCoord($dx, $dy, $dz)) as $block) {
            $this->targetManager->removeBlock($this, $block->getPosition()->getX(), $block->getPosition()->getY(), $block->getPosition()->getZ());
        }
    }

    /**
     * @param int $seconds
     */
    public function setOnFire(int $seconds): void
    {
    }

    /**
     * @return EntitySizeInfo
     */
    protected function getInitialSizeInfo(): EntitySizeInfo
    {
        return new EntitySizeInfo($this->height, $this->width);
    }

    /**
     * @return string
     */
    public static function getNetworkTypeId(): string
    {
        return self::NETWORK_ID;
    }

    /**
     * @return string
     */
    public function getName(): string
    {
        return "DragonNBW";
    }
}
